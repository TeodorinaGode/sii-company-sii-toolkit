import { Component, Input } from '@angular/core';
import { RouterLink } from '@angular/router';
import { MatMenuTrigger, MatMenu, MatMenuItem } from '@angular/material/menu';
import { MatButton } from '@angular/material/button';
import { NgClass, AsyncPipe } from '@angular/common';
import * as i0 from "@angular/core";
import * as i1 from "./services/breadcrumb.service";
import * as i2 from "@angular/router";
export class BreadcrumbComponent {
    get breadcrumbList() {
        return this.breadcrumbService.breadcrumb;
    }
    constructor(breadcrumbService, router) {
        this.breadcrumbService = breadcrumbService;
        this.router = router;
    }
    routerLinkClicked(event, index, breadItem) {
        if (index == 0 && !!this.externalHome || !!this.home) {
            event.stopImmediatePropagation();
            if (!!this.home) {
                this.router.navigate(this.home);
            }
            else {
                window.open(this.externalHome, "_self");
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BreadcrumbComponent, deps: [{ token: i1.SiiBreadcrumbService }, { token: i2.Router }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "18.2.13", type: BreadcrumbComponent, isStandalone: true, selector: "sii-breadcrumb", inputs: { externalHome: "externalHome", home: "home" }, ngImport: i0, template: "\r\n@if ((breadcrumbList | async); as lista) {\r\n  <nav>\r\n    @for (bread of lista; track bread; let last = $last; let index = $index) {\r\n      @if (  index==0 || index == lista.length-2 || last) {\r\n        <a  (click)=\"routerLinkClicked($event,index,bread)\" [routerLink]=\" bread.url\" [fragment]=\"bread.fragment\" [queryParams]=\"bread.queryParams\"  [ngClass]=\"{'currentBread':last}\"> {{bread.label}}</a>\r\n        @if (!last) {\r\n          <span style=\" padding: 0 10px;\">/</span>\r\n        }\r\n      }\r\n      @if (lista.length>3 &&  index==1 ) {\r\n        <button mat-button [matMenuTriggerFor]=\"menu\" class=\"ellipsedItemsButton\">...</button>\r\n        <mat-menu #menu=\"matMenu\">\r\n          @for (menubread of lista; track menubread; let lastmb = $last; let indexmb = $index) {\r\n            @if (indexmb>=1 && indexmb<lista.length-2) {\r\n              <a mat-menu-item  [routerLink]=\" menubread.url\" [fragment]=\"menubread.fragment\" [queryParams]=\"menubread.queryParams\"   >{{menubread.label}}</a>\r\n            }\r\n          }\r\n        </mat-menu>\r\n        @if (!last) {\r\n          <span style=\" padding: 0 10px;\">/</span>\r\n        }\r\n      }\r\n    }\r\n  </nav>\r\n}\r\n", styles: ["nav a{color:inherit;text-decoration:auto;display:inline-block;text-transform:capitalize}nav a:hover{text-decoration:underline}nav a.currentBread{pointer-events:none;opacity:.8}nav a.currentBread:after{content:unset}.ellipsedItemsButton{min-width:20px;margin:0 -15px}\n"], dependencies: [{ kind: "directive", type: RouterLink, selector: "[routerLink]", inputs: ["target", "queryParams", "fragment", "queryParamsHandling", "state", "info", "relativeTo", "preserveFragment", "skipLocationChange", "replaceUrl", "routerLink"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "component", type: MatButton, selector: "    button[mat-button], button[mat-raised-button], button[mat-flat-button],    button[mat-stroked-button]  ", exportAs: ["matButton"] }, { kind: "directive", type: MatMenuTrigger, selector: "[mat-menu-trigger-for], [matMenuTriggerFor]", inputs: ["mat-menu-trigger-for", "matMenuTriggerFor", "matMenuTriggerData", "matMenuTriggerRestoreFocus"], outputs: ["menuOpened", "onMenuOpen", "menuClosed", "onMenuClose"], exportAs: ["matMenuTrigger"] }, { kind: "component", type: MatMenu, selector: "mat-menu", inputs: ["backdropClass", "aria-label", "aria-labelledby", "aria-describedby", "xPosition", "yPosition", "overlapTrigger", "hasBackdrop", "class", "classList"], outputs: ["closed", "close"], exportAs: ["matMenu"] }, { kind: "component", type: MatMenuItem, selector: "[mat-menu-item]", inputs: ["role", "disabled", "disableRipple"], exportAs: ["matMenuItem"] }, { kind: "pipe", type: AsyncPipe, name: "async" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.2.13", ngImport: i0, type: BreadcrumbComponent, decorators: [{
            type: Component,
            args: [{ selector: 'sii-breadcrumb', standalone: true, imports: [
                        RouterLink,
                        NgClass,
                        MatButton,
                        MatMenuTrigger,
                        MatMenu,
                        MatMenuItem,
                        AsyncPipe,
                    ], template: "\r\n@if ((breadcrumbList | async); as lista) {\r\n  <nav>\r\n    @for (bread of lista; track bread; let last = $last; let index = $index) {\r\n      @if (  index==0 || index == lista.length-2 || last) {\r\n        <a  (click)=\"routerLinkClicked($event,index,bread)\" [routerLink]=\" bread.url\" [fragment]=\"bread.fragment\" [queryParams]=\"bread.queryParams\"  [ngClass]=\"{'currentBread':last}\"> {{bread.label}}</a>\r\n        @if (!last) {\r\n          <span style=\" padding: 0 10px;\">/</span>\r\n        }\r\n      }\r\n      @if (lista.length>3 &&  index==1 ) {\r\n        <button mat-button [matMenuTriggerFor]=\"menu\" class=\"ellipsedItemsButton\">...</button>\r\n        <mat-menu #menu=\"matMenu\">\r\n          @for (menubread of lista; track menubread; let lastmb = $last; let indexmb = $index) {\r\n            @if (indexmb>=1 && indexmb<lista.length-2) {\r\n              <a mat-menu-item  [routerLink]=\" menubread.url\" [fragment]=\"menubread.fragment\" [queryParams]=\"menubread.queryParams\"   >{{menubread.label}}</a>\r\n            }\r\n          }\r\n        </mat-menu>\r\n        @if (!last) {\r\n          <span style=\" padding: 0 10px;\">/</span>\r\n        }\r\n      }\r\n    }\r\n  </nav>\r\n}\r\n", styles: ["nav a{color:inherit;text-decoration:auto;display:inline-block;text-transform:capitalize}nav a:hover{text-decoration:underline}nav a.currentBread{pointer-events:none;opacity:.8}nav a.currentBread:after{content:unset}.ellipsedItemsButton{min-width:20px;margin:0 -15px}\n"] }]
        }], ctorParameters: () => [{ type: i1.SiiBreadcrumbService }, { type: i2.Router }], propDecorators: { externalHome: [{
                type: Input
            }], home: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJlYWRjcnVtYi5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9zaWktdG9vbGtpdC9zcmMvbGliL2NvbXBvbmVudHMvYnJlYWRjcnVtYi9icmVhZGNydW1iLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3NpaS10b29sa2l0L3NyYy9saWIvY29tcG9uZW50cy9icmVhZGNydW1iL2JyZWFkY3J1bWIuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFHLFNBQVMsRUFBRSxLQUFLLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDakQsT0FBTyxFQUFVLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRXJELE9BQU8sRUFBRSxjQUFjLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzlFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNyRCxPQUFPLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7O0FBaUJyRCxNQUFNLE9BQU8sbUJBQW1CO0lBSTlCLElBQUksY0FBYztRQUNoQixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUM7SUFDM0MsQ0FBQztJQUdELFlBQXNCLGlCQUF1QyxFQUFXLE1BQWM7UUFBaEUsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFzQjtRQUFXLFdBQU0sR0FBTixNQUFNLENBQVE7SUFDdEYsQ0FBQztJQUVELGlCQUFpQixDQUFDLEtBQVcsRUFBRSxLQUFZLEVBQUUsU0FBd0I7UUFDbkUsSUFBRyxLQUFLLElBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFDLENBQUM7WUFDakQsS0FBSyxDQUFDLHdCQUF3QixFQUFFLENBQUM7WUFDakMsSUFBRyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksRUFBQyxDQUFDO2dCQUNkLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNsQyxDQUFDO2lCQUFJLENBQUM7Z0JBQ0osTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3pDLENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQzsrR0FyQlUsbUJBQW1CO21HQUFuQixtQkFBbUIsa0lDdEJoQyxndENBMEJBLHNVRGJRLFVBQVUsb09BQ1YsT0FBTyxvRkFDUCxTQUFTLGlMQUNULGNBQWMscVNBQ2QsT0FBTywyUUFDUCxXQUFXLGlJQUNYLFNBQVM7OzRGQUdKLG1CQUFtQjtrQkFmL0IsU0FBUzsrQkFDSSxnQkFBZ0IsY0FHZCxJQUFJLFdBQ1A7d0JBQ0wsVUFBVTt3QkFDVixPQUFPO3dCQUNQLFNBQVM7d0JBQ1QsY0FBYzt3QkFDZCxPQUFPO3dCQUNQLFdBQVc7d0JBQ1gsU0FBUztxQkFDWjs4R0FHTSxZQUFZO3NCQUFwQixLQUFLO2dCQUNHLElBQUk7c0JBQVosS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7ICBDb21wb25lbnQsIElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUm91dGVyLCBSb3V0ZXJMaW5rIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgQnJlYWRjcnVtYkl0ZW0sIFNpaUJyZWFkY3J1bWJTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy9icmVhZGNydW1iLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBNYXRNZW51VHJpZ2dlciwgTWF0TWVudSwgTWF0TWVudUl0ZW0gfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9tZW51JztcclxuaW1wb3J0IHsgTWF0QnV0dG9uIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvYnV0dG9uJztcclxuaW1wb3J0IHsgTmdDbGFzcywgQXN5bmNQaXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICdzaWktYnJlYWRjcnVtYicsXHJcbiAgICB0ZW1wbGF0ZVVybDogJy4vYnJlYWRjcnVtYi5jb21wb25lbnQuaHRtbCcsXHJcbiAgICBzdHlsZVVybHM6IFsnLi9icmVhZGNydW1iLmNvbXBvbmVudC5zY3NzJ10sXHJcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxyXG4gICAgaW1wb3J0czogW1xyXG4gICAgICAgIFJvdXRlckxpbmssXHJcbiAgICAgICAgTmdDbGFzcyxcclxuICAgICAgICBNYXRCdXR0b24sXHJcbiAgICAgICAgTWF0TWVudVRyaWdnZXIsXHJcbiAgICAgICAgTWF0TWVudSxcclxuICAgICAgICBNYXRNZW51SXRlbSxcclxuICAgICAgICBBc3luY1BpcGUsXHJcbiAgICBdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgQnJlYWRjcnVtYkNvbXBvbmVudCB7XHJcbiAgQElucHV0KCkgZXh0ZXJuYWxIb21lOnN0cmluZyB8IFVSTDtcclxuICBASW5wdXQoKSBob21lOmFueVtdO1xyXG5cclxuICBnZXQgYnJlYWRjcnVtYkxpc3QoKXtcclxuICAgIHJldHVybiB0aGlzLmJyZWFkY3J1bWJTZXJ2aWNlLmJyZWFkY3J1bWI7XHJcbiAgfVxyXG5cclxuXHJcbiAgY29uc3RydWN0b3IoICBwcml2YXRlIGJyZWFkY3J1bWJTZXJ2aWNlOiBTaWlCcmVhZGNydW1iU2VydmljZSwgIHByaXZhdGUgcm91dGVyOiBSb3V0ZXIgICkge1xyXG4gIH1cclxuXHJcbiAgcm91dGVyTGlua0NsaWNrZWQoZXZlbnQ6RXZlbnQgLGluZGV4Om51bWJlciwgYnJlYWRJdGVtOkJyZWFkY3J1bWJJdGVtKXtcclxuICAgIGlmKGluZGV4PT0wICYmICEhdGhpcy5leHRlcm5hbEhvbWUgfHwgISF0aGlzLmhvbWUpe1xyXG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgaWYoISF0aGlzLmhvbWUpe1xyXG4gICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKHRoaXMuaG9tZSk7XHJcbiAgICAgIH1lbHNle1xyXG4gICAgICAgIHdpbmRvdy5vcGVuKHRoaXMuZXh0ZXJuYWxIb21lLFwiX3NlbGZcIik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG5cclxufVxyXG4iLCJcclxuQGlmICgoYnJlYWRjcnVtYkxpc3QgfCBhc3luYyk7IGFzIGxpc3RhKSB7XHJcbiAgPG5hdj5cclxuICAgIEBmb3IgKGJyZWFkIG9mIGxpc3RhOyB0cmFjayBicmVhZDsgbGV0IGxhc3QgPSAkbGFzdDsgbGV0IGluZGV4ID0gJGluZGV4KSB7XHJcbiAgICAgIEBpZiAoICBpbmRleD09MCB8fCBpbmRleCA9PSBsaXN0YS5sZW5ndGgtMiB8fCBsYXN0KSB7XHJcbiAgICAgICAgPGEgIChjbGljayk9XCJyb3V0ZXJMaW5rQ2xpY2tlZCgkZXZlbnQsaW5kZXgsYnJlYWQpXCIgW3JvdXRlckxpbmtdPVwiIGJyZWFkLnVybFwiIFtmcmFnbWVudF09XCJicmVhZC5mcmFnbWVudFwiIFtxdWVyeVBhcmFtc109XCJicmVhZC5xdWVyeVBhcmFtc1wiICBbbmdDbGFzc109XCJ7J2N1cnJlbnRCcmVhZCc6bGFzdH1cIj4ge3ticmVhZC5sYWJlbH19PC9hPlxyXG4gICAgICAgIEBpZiAoIWxhc3QpIHtcclxuICAgICAgICAgIDxzcGFuIHN0eWxlPVwiIHBhZGRpbmc6IDAgMTBweDtcIj4vPC9zcGFuPlxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBAaWYgKGxpc3RhLmxlbmd0aD4zICYmICBpbmRleD09MSApIHtcclxuICAgICAgICA8YnV0dG9uIG1hdC1idXR0b24gW21hdE1lbnVUcmlnZ2VyRm9yXT1cIm1lbnVcIiBjbGFzcz1cImVsbGlwc2VkSXRlbXNCdXR0b25cIj4uLi48L2J1dHRvbj5cclxuICAgICAgICA8bWF0LW1lbnUgI21lbnU9XCJtYXRNZW51XCI+XHJcbiAgICAgICAgICBAZm9yIChtZW51YnJlYWQgb2YgbGlzdGE7IHRyYWNrIG1lbnVicmVhZDsgbGV0IGxhc3RtYiA9ICRsYXN0OyBsZXQgaW5kZXhtYiA9ICRpbmRleCkge1xyXG4gICAgICAgICAgICBAaWYgKGluZGV4bWI+PTEgJiYgaW5kZXhtYjxsaXN0YS5sZW5ndGgtMikge1xyXG4gICAgICAgICAgICAgIDxhIG1hdC1tZW51LWl0ZW0gIFtyb3V0ZXJMaW5rXT1cIiBtZW51YnJlYWQudXJsXCIgW2ZyYWdtZW50XT1cIm1lbnVicmVhZC5mcmFnbWVudFwiIFtxdWVyeVBhcmFtc109XCJtZW51YnJlYWQucXVlcnlQYXJhbXNcIiAgID57e21lbnVicmVhZC5sYWJlbH19PC9hPlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgPC9tYXQtbWVudT5cclxuICAgICAgICBAaWYgKCFsYXN0KSB7XHJcbiAgICAgICAgICA8c3BhbiBzdHlsZT1cIiBwYWRkaW5nOiAwIDEwcHg7XCI+Lzwvc3Bhbj5cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICA8L25hdj5cclxufVxyXG4iXX0=